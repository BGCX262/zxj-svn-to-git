/*
 * Created on Jan 28, 2004 by Michael Brewer
 * $Id: ZX.java,v 1.1.2.50 2006/07/24 15:46:21 mike Exp $
 */
package org.zxframework;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import java.text.DateFormat;
import java.text.ParseException;
import java.util.Date;
import java.util.Iterator;
import java.util.Properties;

/** 
 * XML Parsing imports, may need to may this into the zX Descriptor.
 *  
 * NOTE : Websphere also has JDOM in its classpath, 
 * but it is out of date with this one. So we have 
 * to make sure that these to classpathes do not conflict.
 **/
import org.jdom.CDATA;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.Text;
import org.jdom.input.SAXBuilder;
import org.jdom.xpath.XPath;

/** 
 * Caching api 
 */
import org.zxframework.cache.Cache;
import org.zxframework.cache.CacheProvider;

import org.zxframework.datasources.DataSources;

import org.zxframework.director.DirectorHandler;
import org.zxframework.director.DrctrFH;
import org.zxframework.director.DrctrFHDefault;
import org.zxframework.doc.OpenOfficeDocument;
import org.zxframework.exception.NestableException;
import org.zxframework.exception.NestableRuntimeException;
import org.zxframework.expression.ExpressionHandler;

import org.zxframework.property.BooleanProperty;
import org.zxframework.property.DateProperty;
import org.zxframework.property.DoubleProperty;
import org.zxframework.property.LongProperty;
import org.zxframework.property.Property;
import org.zxframework.property.StringProperty;

import org.zxframework.sql.SQL;

import org.zxframework.util.PropertiesUtil;
import org.zxframework.util.ReflectUtil;
import org.zxframework.util.StringUtil;

import org.zxframework.logging.Log;
import org.zxframework.logging.LogFactory;

/**
 * Core zX object that inits the logging etc. 
 *
 * Here is an example xml config file : 
 * <code><pre>
&lt;zX>
	&lt;appName>zxOne&lt;/appName>
	&lt;baseDir>/project/test/&lt;/baseDir>	
	&lt;log>
		&lt;logFactory>org.zxframework.logging.impl.Log4jFactory&lt;/logFactory>	
		&lt;fileName>test.log&lt;/fileName>
		
		&lt;active>1&lt;/active>
		&lt;append>yes&lt;/append>

		&lt;logLevel>DEBUG&lt;/logLevel>
		&lt;logFormat>%d{ISO8601} -  %p - %m%n&lt;/logFormat>
	&lt;/log>
	&lt;trace>
		&lt;fileName>zxOne.trc&lt;/fileName>
		&lt;append>yes&lt;/append>
		
		&lt;active>yes&lt;/active>
		&lt;level>3&lt;/level>
		&lt;logFormat>%d{ISO8601} - %m%n&lt;/logFormat>		
	&lt;/trace>
&lt;/zX>
</pre>
 * </code>
 * 
 * <pre>
 * 
 * This class is the main context for zx and acts as a factory for the zX runtime environment 
 * as well as for business objects and is a placeholder for global context. A handle to this object is 
 * passed  to every object that is generated by this factory class.
 * 
 * Change    : DGS22JAN2003
 * Why       : New shutdown function, required by Repository Editor when re-connecting to zX.
 * 
 * Change    : BD17FEB03
 * Why       : Added database stored system messages support
 * 
 * Change    : BD19FEB03
 * Why       : Added actionContext
 * 
 * Change    : BD12MAR03
 * Why       : Added resolveDirector
 * 
 * Change    : BD23MAR03
 * Why       : Add BOLock support
 * 
 * Change    : BD27MAR03
 * Why       : Added local traceActive flag to save CPU cycles as
 *             zx.traceActive is cheaper than zX.trace.traceActive
 * 
 * Change    : BD9MAY03
 * Why       : - Added quick context + BO context
 *             - Support include files in config file
 *             - Framework global director handling
 * 
 * Change    : BD22MAY03
 * Why       : - Added configXMLNode function
 * 
 * Change    : BD30JUN03
 * Why       : Set runmode on init
 * 
 * Change    : BD28AUG03
 * Why       : Do not generate error message when there is no need
 *             in saveCollectionItem
 * 
 * Change    : BD3SEP03
 * Why       : Added createFKBO method
 * 
 * Change    : BD28OCT03
 * Why       : No longer support indexed positions in saveCollection routines;
 *             this not only makes the routines a bit faster but more importantly
 *             deals with the confusion that you get when a key happens to
 *             be numeric
 * 
 * Change    : DGS02FEB2004
 * Why       : Minor tweaks to improve error message when cannot parse XML
 * 
 * Change    : BD28MAR04
 * Why       : Added postPersistLastRc; this is a bit of an ugly solution to
 *             the following problem. Imagine that we call prePersist and
 *             postPersist as part of, say, deleteBO. And that, for whatever
 *             reason the delete fails. In this case we may want to do
 *             special things in the postPersist. We should really have
 *             included the return code of whatever we do as a parameter
 *             to postPersist. Adding it now would cause MASSIVE rework
 *             on existing code so it is now done through this special
 *             global variable in zX
 *               
 * Change    : MB23SEP2004
 * Why       : Added a setting for the enviroment type, this is only used by the editor
 * 
 * Change    : DGS27SEP2004
 * Why       : appDate now returns 'now' every time, rather than set once and return same
 *             value. Unless it is explicltly set to something, when it behaves as before.
 *              
 * Change    : BD18OCT04
 * Why       : When in editor-mode, do never cache descriptors
 * 
 * Change    : BD24MAR05 V1.5:1
 * Why       :   - Support for required zX version
 *               - Support for data sources / persistence channels
 *               
 * Change    : BD19JUN05 V1.5:19
 * Why       : Added nullValue method (to be used instead of strValue with null option
 * 
 * Change    : BD28APR2006 (BD26MAR06) - V1.5:95
 * Why       : Added defaultInterface method (Not needed in java)
 * 
 * </pre>
 * 
 * @author Michael Brewer
 * @author Bertus Dispa
 * @author David Swann
 * 
 * @version 0.0.1
 */
public class ZX {
    
    //------- Logging and tracing made visible for easy of use.
    
    /** 
     * <code>log</code>- The zx logging used accross all of the framework.
     * 
     * We will initially set this up to log using the default log4j.properties settings.
     * zX xml config file may override this.
     * 
     * This is so that we can log stuff write at the beginning.
     * */
    public Log log = LogFactory.getLog(ZX.class);
    
	/** <code>trace</code> - The zx tracing used across all of the framework.*/
	public Trace trace;
    
    /** <code>throwException</code> -  Whether zx based methods should throws zxexceptions. */
    public boolean throwException = true;
    
    /** 
     * Cache the top xml element so we can call configValue on it. 
     * NOTE : This may be removed if we use Sax rather than Dom. 
     */
	private Element configXMLTop;
    
    private DirectorHandler directorHandler;
    private DrctrFH defaultDirectorFuncHandler;
    private ExpressionHandler expressionHandler;
	
	/** <code>sql</code> - Th sql generation class  */
	public SQL sql;
    /** A handle to Business object helper methods. */
    private ZXBOS bos;
	
	/** A handle to the current logged in user */	
	private UserProfile userProfile;
    
	/** A handle to the message object. */
	private Message msg;
    
	/** A handle to the Lock business object to keep track of locked entities. */
	private Lock BOLock;
    
    /** A handle to the session object.*/
    private Session session;
    
	/** Quick storage area for global application access. */
	private QuickContext quickContext;
	/** Quick storage area for business object and is globally accessiable. */
	private BOCntxt BOContext;
	
    // Event actions
	private String actionContext;
    
	/** See comment in header for explanation (marked with BD28MAR04) */
	private zXType.rc postPersistLastRc;
    
    /** The current date. */
    private Date appDate;
    
    /** dataSources - Handle to the datasources object. */
    private DataSources dataSources;
    
    //----------------------------- Caching
    private Cache cache;
    private boolean isInCached = false;
    
    /** zX enviroment settings. */
    public static Settings settings;
    
    /** The date when the zX config file was last updated. */
    private static long cfgLastModified = 0;
    //------------------------------ Caching
    
    private static final Properties ZXCORE_PROPERTIES;
    
    static {
        Log log = LogFactory.getLog(ZX.class);
        ZXCORE_PROPERTIES = new Properties();
        InputStream stream = Environment.class.getResourceAsStream("/zX.properties");
        if ( stream == null ) {
            log.info("zX.properties not found");
        } else {
            try {
                ZXCORE_PROPERTIES.load(stream);
                log.trace("loaded properties from resource zX.properties: " + PropertiesUtil.maskOut(ZXCORE_PROPERTIES, "password"));
            } catch (Exception e) {
                log.error("problem loading properties from zX.properties");
            } finally {
                try{
                    stream.close();
                } catch (IOException ioe){
                    log.error("could not close stream on zX.properties", ioe);
                }
            }
        }
    }
    
    //------------------------------------ Constants
    
    /** Namespace for the cached business objects. */
    private static final String ENTITY_NS = "zxbo.";
    
    //---------------------------------------------------------- Constructors.
    
	/**
	 * Hidden : You need the call zXConfig with the filename
	 */
	private ZX() {
        super();
	}
	
	/**
	 * Initialise the zX framework by reading and processing the application confirguration file.
	 * 
	 * NOTE : Tracing can not be used here, tracing needs zx to be initialised.
	 * 
	 * @param zXConfigFile The xml config file for zx, this loaded from the classpath for now. Probably should more elsewhere.
	 * @throws ZXException This is a fatal exception, as zx itself cannot be initialed
	 */
	public ZX(String zXConfigFile) throws ZXException {
        // Configure zx
	    init(zXConfigFile);
	}

	/**
	 * This makes sure that the port is as close to the original, however is actually get
	 * calls the construtor.
	 * 
	 * @param zXConfigFile Just the name of the config file eg : zX.xml. As it is loaded from the classpath.
	 * @throws ZXException if the ZX constructor failed it will throw up a ZXException. the has already handled the exception. 
	 */
	private void init(String zXConfigFile) throws ZXException {
        /**
         * Setup the caching.
         * 
         * These settings are read from the properties file.
         */
        if (PropertiesUtil.getBoolean(Environment.USE_CACHE, ZXCORE_PROPERTIES)) {
            try {
                CacheProvider objCacheProp = createCacheProvider();
                objCacheProp.start(ZXCORE_PROPERTIES);
                
                this.cache = objCacheProp.buildCache(PropertiesUtil.getString(Environment.CACHE_NAME, ZXCORE_PROPERTIES, "zX"),
                									 ZXCORE_PROPERTIES);
                
            } catch (Exception e) {
                log.error("Failed to init caching", e);
                
            }
        }
        
	    /**
	     * Store this instance of zx in thread local.
	     * 
	     * NOTE : This need to be done as soon as coz
	     * allow ZXObject object get a handle to zx from this.
	     */
	    ThreadLocalZX.setZX(this);
        
	    /**
	     * Initialise quick and BO context objects
	     */
	    this.quickContext = new QuickContext();
	    this.BOContext = new BOCntxt();
        
	    try {
	        /**
	         * Parse the zx cfg file.
	         */
	        parseZXConfig(zXConfigFile);
            
			/**
			 * We can now start tracing.
			 */
			if (trace.isFrameworkCoreTraceEnabled()) {
	            trace.enterMethod();
	            trace.traceParam("zXConfigFile", zXConfigFile);
	        }
			
	    } catch (Exception e) {
            log.error(" Failed in the core part of initiliasation.", e);
	        throw new ZXException("Failed in the core part of initiliasation.", e);
	    }
	    
	    /**
	     * Now that the tracing is enabled we 
	     * can start to do standard tracing.
	     */
        try {
        	/**
        	 * Check if we have set up a global cache agent
        	 */
        	if (this.cache == null) {
        		switch (getSettings().getRunMode().pos) {
				case 0 : case 5:
					log.warn("No global cache provided");
					break;
				}
        	}
        	
    		/**
    		 * Initialise the SQL class :
    		 */
    		sql = new SQL();
            
    		/**
    		 * Initialise the data sources
    		 */
            getDataSources().parseConfig();
    		getDataSources().init();
			
    		/**
    		 * Initialise session object
    		 */
    		setSession((Session)createBO("zxSssn"));
    		if (this.session == null) {
    		    throw new Exception("Failed to : Get to create a session object");
    		}
    		
    	    /**
    	     * Get handle to userprofile object
    	     **/
    	    this.userProfile = (UserProfile)createBO("zxUsrPrf");
    	    if (this.userProfile == null) {
    	        throw new Exception("Failed to create userProfile");    		
    	    }
    	    
    	    /**
    	     * And get msg object (BD17FEB03)
    	     */
    	    this.msg = (Message)createBO("zXMsg");
    	    if (this.msg == null) {
    	        throw new ZXException("Failed to create the message object.");
    	    }
    	    
    	    /**
    	     * Get director handler up to speed.
    	     * Init the default director function handler.
    	     */
            directorHandler = new DirectorHandler();
    	    /** Init the default director handler to be DrctrFHDefault. **/
    	    defaultDirectorFuncHandler = new DrctrFHDefault();
    	    directorHandler.registerFH("default", defaultDirectorFuncHandler);
    	    
		    /**
		     * Initialize the expressions handler
		     */
		    this.expressionHandler = new ExpressionHandler();
            
            /**
             * Everything was sucessful.
             */
            if (log.isInfoEnabled()) {
                log.info("Started ZX successfully for : " + getSettings().getAppName());
            }
            
        } catch (Exception e) {
            trace.addError("Failed to init zx", e);
            throw new ZXException(e);
            
        } finally {
            if (trace.isFrameworkCoreTraceEnabled()) {
                trace.exitMethod();
            }
            
        }
	}
	
	/**
	 * Returns the requested config value from the zXConfigFile.
	 * If the xpath selects a attribute it will return the value 
	 * surrounded in quotes.
	 * 
	 * NOTE : This method cannot have tracing as it is used first before tracing has been initialised.
	 * 
	 * @param xpath Xpath uri of the config you want to select. 
	 * @return Returns the requested string or a empty string..
	 * @throws ZXException Thrown if configValue failes
	 */
	public String configValue(String xpath) {
		String configValue="";
        try {
    		Object valueObj = null;
    		try {
    			valueObj = XPath.selectSingleNode(this.configXMLTop, xpath);
    		} catch (JDOMException e) {
    			throw new NestableException("Xpath failed to select a node : " + xpath, e);
    		}
    		
    		/**
    		 * We only want the string value out : 
    		 */
    		if (valueObj instanceof Element) {
    			configValue = ((Element) valueObj).getText();
    		} else if (valueObj instanceof Text) {
    			configValue = ((Text) valueObj).getText();
    		} else if (valueObj instanceof Attribute) {
    			configValue = ((org.jdom.Attribute) valueObj).getValue();
    		} else if (valueObj instanceof CDATA) {
    			configValue = ((CDATA) valueObj).getText();
    		}
    		
    		return configValue;
        } catch (Exception e) {
            throw new RuntimeException("Failed to get config value for :" + xpath, e);
        }
	}
	
	/**
	 * This will return the xml node for the section you have requested.
	 * 
	 * @param pstrXPath The key of the cache xml node.
	 * @return Returns an xml note from the xpath
	 */
	public Element configXMLNode(String pstrXPath) {
		Element configValue;
        configValue = (Element)settings.getTags().get(pstrXPath);
		return configValue;
	}
    
	// ----------------------- Getters/Setters Methods
    // These are runtime getters and setters.

    /**
     * The handle to the data sources.
     * 
     * @return Returns the dataSources.
     */
    public DataSources getDataSources() {
        return dataSources;
    }
    
    /**
     * @param dataSources The dataSources to set.
     */
    private void setDataSources(DataSources dataSources) {
        this.dataSources = dataSources;
    }
    
    /**
     * @return Returns the msg.
     */
    public Message getMsg() {
        return msg;
    }
    
    /**
     * @return Returns the postPersistLastRc.
     */
    public zXType.rc getPostPersistLastRc() {
        return postPersistLastRc;
    }
    
    /**
     * @param postPersistLastRc The postPersistLastRc to set.
     */
    public void setPostPersistLastRc(zXType.rc postPersistLastRc) {
        this.postPersistLastRc = postPersistLastRc;
    }
    
    /**
     * @return Returns the throwException.
     */
    public boolean isThrowException() {
        return this.throwException;
    }
    
    /**
     * @param throwException The throwException to set.
     */
    public void setThrowException(boolean throwException) {
        this.throwException = throwException;
    }
    
    /**
     * @return Returns the appDate.
     */
    public Date getAppDate() {
        if (appDate == null) {
            // Create date on the fly.
            return new Date();
        }
        return appDate;
    }
    
    /**
     * This is the context variable that is used in the
     * pre- and post persist. This can be set by the user but
     * will ALWAYS be set by the pageflow action
     * 
     * @return Returns the actionContext.
     */
    public String getActionContext() {
        return actionContext;
    }
    
    /**
     * @param actionContext The actionContext to set.
     */
    public void setActionContext(String actionContext) {
        this.actionContext = actionContext;
    }
    
    /**
     * @return Returns the defaultDirectorFuncHandler.
     */
    public DrctrFH getDefaultDirectorFuncHandler() {
        return defaultDirectorFuncHandler;
    }
    
    /**
     * @return Returns the quickContext.
     */
    public QuickContext getQuickContext() {
        return quickContext;
    }
    
    /**
     * @return Returns the bOContext.
     */
    public BOCntxt getBOContext() {
        return BOContext;
    }
    
    /**
     * @return Returns the bOLock.
     * @throws ZXException
     */
    public Lock getBOLock() throws ZXException {
        if(this.BOLock == null) {
            this.BOLock = (Lock)createBO("zXLck");
        }
        return this.BOLock;
    }
    
    /**
     * This only initialises when needed.
     * @return Returns the bos.
     */
    public ZXBOS getBos() {
        if (this.bos == null) {
            bos = new ZXBOS();
        }
        return bos;
    }
    
    /**
     * @return Returns the session.
     */
    public Session getSession() {
        return session;
    }
    
    /**
     * @param session The session to set.
     */
    private void setSession(Session session) {
        this.session = session;
    }
    
    /**
     * @return Returns the directorHandler.
     */
    public DirectorHandler getDirectorHandler() {
        return directorHandler;
    }
    
    /**
     * @return Returns the expressionHandler.
     */
    public ExpressionHandler getExpressionHandler() {
        return expressionHandler;
    }
    
    /**
     * @param appDate The appDate to set.
     */
    public void setAppDate(Date appDate) {
        this.appDate = appDate;
    }
    
    /**
     * @return Returns the sql.
     */
    public SQL getSql() {
        return sql;
    }
    
    /**
     * @return Returns the userProfile.
     */
    public UserProfile getUserProfile() {
        return this.userProfile;
    }
    
    org.zxframework.doc.Document word;
    
    /**
     * @return Returns a handle to Word doc object
     */
    public org.zxframework.doc.Document word() {
    	if (this.word == null) {
        	word = new OpenOfficeDocument();
    	}
    	
    	return word;
    }
    
	// ------------------------------------------------------ Util Methods
    
	/**
	 * Get the full path name of a file from its name. It is build from the 
	 * baseDir up.
	 * 
	 * <pre>
	 * 
	 * NOTE : This method cannot have tracing as it is used first before tracing has been initialised.
	 * </pre>
	 * 
	 * @param pstrFile The path relative from the baseDir.
	 * @return Returns the full path name of the base dir.
	 */
	public String fullPathName(String pstrFile) {
	    /**
	     * If the filename contains either :, \\ or .., we assume that the
	     * filename is already complete and can thus be left untouched
	     */
//	    if (pstrFile.charAt(0) == '/' && 
//	    	pstrFile.indexOf(':') != -1 
//			|| pstrFile.indexOf("//") != -1) {
//	        return pstrFile;
//	    } else {
//	       	return this.baseDir + pstrFile;
//	    }
        
	    return settings.getBaseDir() + pstrFile;
	}
	
	/**
	 * Create instance of BO and load it.
	 * 
	 * NOTE : Origianlly in clsBOS#quickFKLoad()
	 * NOTE : This calls quickLoad(pstrBO, pobjKeyValue, "", "*");
	 * 
	 * @param pstrBO The name of the ZXBO.
	 * @param pobjKeyValue Value of the key. 
	 * @return Returns a instance of  instance of BO
	 * @throws ZXException Thrown if quickLoad fails
	 **/
    public ZXBO quickLoad(String pstrBO, Property pobjKeyValue) throws ZXException {
        return quickLoad(pstrBO, pobjKeyValue, "", "*");
    }
    
	/**
	 * Create instance of BO and load it.
	 * 
	 * <pre>
	 * 
	 * NOTE : Origianlly in clsBOS#quickFKLoad()
	 * NOTE : This calls quickLoad(pstrBO, pobjKeyValue, pstrKeyAttr, "*");
	 * </pre>
	 * 
	 * @param pstrBO The name of the ZXBO.
	 * @param pobjKeyValue Value of the key. 
	 * @param pstrKeyAttr The key attribute to use.
	 * @return Returns a instance of  instance of BO
	 * @throws ZXException Thrown if quickLoad fails
	 **/
    public ZXBO quickLoad(String pstrBO, Property pobjKeyValue, String pstrKeyAttr) throws ZXException {
        return quickLoad(pstrBO, pobjKeyValue, pstrKeyAttr, "*");
    }
    
	/**
	 * Create instance of BO and load it.
	 * 
	 * <pre>
	 * 
	 * NOTE : Origianlly in clsBOS#quickFKLoad()
	 * </pre>
	 * 
	 * @param pstrBO The name of the ZXBO.
	 * @param pobjKeyValue Value of the key. 
	 * @param pstrKeyAttr The key attribute to use. Optional, default is ""
	 * @param pstrLoadGroup Group to load. Optional, default is "*"
	 * 
	 * @return Returns a instance of  instance of BO
	 * @throws ZXException Thrown if quickLoad fails
	 */
	public ZXBO quickLoad(String pstrBO, Property pobjKeyValue,
	        			  String pstrKeyAttr, String pstrLoadGroup) throws ZXException {
        if (trace.isFrameworkTraceEnabled()) {
            trace.enterMethod();
            trace.traceParam("pstrBO", pstrBO);
            trace.traceParam("pobjKeyValue", pobjKeyValue);
            trace.traceParam("pstrKeyAttr", pstrKeyAttr);
            trace.traceParam("pstrLoadGroup", pstrLoadGroup);
        }

	    ZXBO quickLoad = null;
	    
	    /**
	     * Handle defaults 
	     */
	    if (pstrKeyAttr == null) {
	        pstrKeyAttr = "";
	    }
	    if (pstrLoadGroup == null) {
	        pstrLoadGroup = "*";
	    }
	    
        try {
            quickLoad  = createBO(pstrBO);
            if (quickLoad == null) {
                throw new Exception("Unable to create instance of " + pstrBO);
            }
            
            if (StringUtil.len(pstrKeyAttr) == 0) {
                pstrKeyAttr = quickLoad.getDescriptor().getPrimaryKey();
            }
            
            quickLoad.setValue(pstrKeyAttr, pobjKeyValue);
            
            try {
                
                quickLoad.loadBO(pstrLoadGroup, pstrKeyAttr, false);
                
            } catch (Exception e) {
                /**
                 * DGS25MAR2004: Don't raise an error. The calling program won't catch it
                 * unless they explicitly test the return for nothing anyway, and often this
                 * can be called when it is not known if the row exists or not, when the error
                 * adds to the log file unnecessarily.
                 */
            }
            
            return quickLoad;
        } catch (Exception e) {
            trace.addError("Failed to : Create instance of BO and load it", e);
            if (log.isErrorEnabled()) {
                log.error("Parameter : pstrBO = " + pstrBO);
                log.error("Parameter : pobjKeyValue = " + pobjKeyValue);
                log.error("Parameter : pstrKeyAttr = " + pstrKeyAttr);
                log.error("Parameter : pstrLoadGroup = " + pstrLoadGroup);
            }
            if (throwException) throw new ZXException(e);
            return quickLoad;
        } finally {
            if (trace.isFrameworkTraceEnabled()) {
                trace.returnValue(quickLoad);
                trace.exitMethod();
            }
        }
	}	
	
	/**
	 * createBO - Create a business object.
	 * 
	 * NOTE : This calls createBO(pstrEntity, false)
	 * 
	 * @param pstrEntity The name of BO.
	 * @return Returns a ZXBO, but by default settings.
	 * @throws ZXException Thrown if createBO fails
	 */
	public ZXBO createBO(String pstrEntity) throws ZXException {
	    return createBO(pstrEntity, false);
	}
	
	/**
     * createBO - Create a business object.
     * 
     * NOTE : Should createBO return a zxbo object ?
     * 
     * @param pstrEntity Name of business object
     * @param pblnPrivateDesc Indicates that the descriptor is never to be re-used.
     *                        Optional, defaults is false
     * @return Returns a generic object, but it may return a ZXBO.
     * @throws ZXException Thrown if createBO fails
     */
    public ZXBO createBO(String pstrEntity, boolean pblnPrivateDesc) throws ZXException {
        ZXBO createBO = null;
        Object objCached = null;
        
        if (trace.isFrameworkTraceEnabled()) {
            trace.enterMethod();
            trace.traceParam("pstrEntity", pstrEntity);
            trace.traceParam("pblnPrivateDesc", pblnPrivateDesc);
        }
        
        try {
            
            /**
             * Try to get a cached version if pblnPrivateDesc was off.
             */
            if (!pblnPrivateDesc) {
                objCached = getCacheZXBO(pstrEntity);
                if (objCached != null) {
                    if (StringUtil.len(((ZXBO)objCached).getDescriptor().getAlias()) == 0) { 
                        createBO = ((ZXBO)objCached).cloneBO();   
                        return createBO;
                    }
                    objCached = null;
                }
            }
            
            String strFilename = fullPathName(getSettings().getBoDir())  + File.separatorChar +  pstrEntity.trim() + ".xml";
            
            Descriptor objDesc = new Descriptor();
            objDesc.init(strFilename, false);
            
            /**
             * Create instance of business object class
             */
            try {
                createBO = (ZXBO)createObject(objDesc.getClassName());
            } catch (Exception e) {
                throw new Exception("Failed to : createBO - Create a business object : " + objDesc.getClassName());
            }

            /**
             * And initialise
             */
            createBO.init(objDesc);
            
            /**
             * Mark as new
             */
            createBO.setPersistStatus(zXType.persistStatus.psNew);
            
            return createBO;
            
        } catch (Exception e) {
            trace.addError("Failed to : createBO - Create a business object. ", e);
            if (log.isErrorEnabled()) {
                log.error("Parmater : pstrEntity = " + pstrEntity);
                log.error("Parameter : pblnPrivateDesc =" + pblnPrivateDesc);
            }
            if (this.throwException) throw new ZXException(e);
            return createBO;
        } finally {
            /**
             * Store in cache
             */
            if(!pblnPrivateDesc) {
                /** 
                 * No need to store if we GOT it from the cache in the first place 
                 **/
                if (objCached == null) {
                    String strCacheName = ENTITY_NS + pstrEntity.toLowerCase();
                    if (getSettings().getRunMode().pos == zXType.runMode.rmProduction.pos 
                        || getSettings().getRunMode().pos == zXType.runMode.rmDevelCache.pos) {
                    	// Persistent caching.
                        setCachedValue(strCacheName, createBO);
                    } else {
                        // Traditional style caching.
                        getSettings().getTags().put(strCacheName, createBO);
                    }
                    
                }
            }
            
            if (trace.isFrameworkTraceEnabled()) {
                trace.returnValue(createBO);
                trace.exitMethod();
            }
        }
    }
    
    /**
     * createFKBO - Create an instance of a business object and link it to the given BO.
     * 
     * @param pobjBO The business object with a foriegn key to the named entity.
     * @return Returns the linked business object.
     * @throws ZXException Thrown if createFKBO fails
     */
    public ZXBO createFKBO(ZXBO pobjBO) throws ZXException { 
    	return createFKBO(pobjBO, "", false, "", false, false); 
    }
    
    /**
     * createFKBO - Create an instance of a business object and link it to the given BO.
     * 
	 * @param pobjBO The business object with a foriegn key to the named entity. 
     * @param pstrEntity What entity do we want to create an instance of?
     * @return Returns the linked business object.
     * @throws ZXException Thrown if createFKBO fails
     */
    public ZXBO createFKBO(ZXBO pobjBO, String pstrEntity) throws ZXException { 
    	return createFKBO(pobjBO, pstrEntity, 
    					  false, "", true, true); 
    }
    
    /**
     * createFKBO - Create an instance of a business object and link it to the given BO.
     * 
	 * @param pobjBO The business object with a foriegn key to the named entity. 
     * @param pstrEntity What entity do we want to create an instance of?
     * @param pblnPrivateDesc Use a private descriptor or use from cache if available.
     *                        Optional, defaults is false.
	 * @param pstrAttr The link attribute from <entity> to the given BO; if left blank figure it out yourself
	 * @param pblnReset Reset? Optional, default is true.
	 * @param pblnAssignAutomatics Set automatics? Optional, default is true.
     * @return Returns the linked business object.
     * 
     * @throws ZXException Thrown if createBO fails
     */
    public ZXBO createFKBO(ZXBO pobjBO,
    					   String pstrEntity,
    					   boolean pblnPrivateDesc,
    					   String pstrAttr,
    					   boolean pblnReset,
    					   boolean pblnAssignAutomatics) throws ZXException {
        ZXBO createFKBO = null;
        
        if (trace.isFrameworkTraceEnabled()) {
            trace.enterMethod();
            trace.traceParam("pstrEntity", pstrEntity);
            trace.traceParam("pblnPrivateDesc", pblnPrivateDesc);
        }
        
        try {
        	/**
             * Create the business object
             **/
            createFKBO = createBO(pstrEntity, pblnPrivateDesc);
            if (createFKBO == null) {
            	throw new ZXException("Failed to create FK BO", pstrEntity);
            }

            /**
             * Reset if required
             **/
            if (pblnReset) {
                createFKBO.resetBO();
            }
            
            /**
             * Assign automatics if required
             **/
            if (pblnAssignAutomatics) {
                createFKBO.setAutomatics("+");
            }
            
            /**
             * Set foreign key; name of attr may be passed as parameter in case an
             * entity has multiple attributes
             **/
            if (StringUtil.len(pstrAttr) == 0) {
                Attribute objAttr = createFKBO.getFKAttr(pobjBO);
                
                if (objAttr == null) {
                	throw new ZXException("Failed to get PF Attr");
                }
                
                createFKBO.setValue(objAttr.getName(), pobjBO.getPKValue());
                
            } else {
            	createFKBO.setValue(pstrAttr, pobjBO.getPKValue());
            }
            
        	return createFKBO;
        } catch (Exception e) {
            trace.addError("Failed to : createBO - Create a business object. ", e);
            if (log.isErrorEnabled()) {
                log.error("Parmater : pstrEntity = " + pstrEntity);
                log.error("Parameter : pblnPrivateDesc =" + pblnPrivateDesc);
            }
            
            if (this.throwException) throw new ZXException(e);
            return createFKBO;
        } finally {
            if (trace.isFrameworkTraceEnabled()) {
                trace.returnValue(createFKBO);
                trace.exitMethod();
            }
        }
    }
    
	/**
	 * Try to get Business object from .
	 * 
	 * NOTE :  The entityname has to include a "ZX" if retrieving a ZXBO.
	 * 
	 * @param entityName The entity name of the ZXBO.
	 * @return Gets a ZXBO object from the collection of Objects.
	 */
	public Object getCacheZXBO(String entityName) {
	    Object getCacheZXBO = null;
        
	    String strEntity = ENTITY_NS + entityName.toLowerCase();
	    if (getSettings().getRunMode().pos == zXType.runMode.rmProduction.pos) {
	    	/**
	    	 * Ignore any updated on the file, we are now in production.
	    	 */
	        getCacheZXBO = getCachedValue(strEntity);
	        
	    } else if (getSettings().getRunMode().pos == zXType.runMode.rmDevelCache.pos) {
	    	/**
	    	 * Get a cache version of the bo if the file descriptor has not been modified recently.
	    	 */
	        getCacheZXBO = getCachedValue(strEntity);
	        
	        if (getCacheZXBO != null) {
	        	String strFileName = fullPathName(getSettings().getBoDir())  + File.separatorChar + entityName + ".xml";
                File file = new File(strFileName);
                long lastModified = file.lastModified();
                if (lastModified > ((ZXBO)getCacheZXBO).getDescriptor().getLastModified()) {
                    getCacheZXBO = null;
                }
	        }
	        
	    } else if (getSettings().getTags().size() > 0) {
	    	/**
	    	 * Runtime cache only.
	    	 */
	    	getCacheZXBO = getSettings().getTags().get(strEntity);
	    }
	    
		return getCacheZXBO;
	}
	
	/**
	 * This tries to load a ZXBO class by is name by using Reflection and tries
	 * to create an instance of that object.
	 * 
	 * <pre>
	 * 
	 * NOTE : This automatically calls the constructor that initliases zx. So beware of trying to call ZXObject that do not have a ZX constructor.
	 * NOTE : This is a fully qualified class name 
	 * eg : com.zx.bo.ZXBO
	 * </pre>
	 * 
	 * @param className The name of the class you want to create a instance of
	 * @return Returns an instance of the 
	 * @throws ZXException Thrown if createObject failes.
	 */
	public Object createObject(String className) throws ZXException{
		Object createObject = null;
		try {
			Class cls = ReflectUtil.classForName(className);
			createObject = cls.newInstance();
			return createObject;
		} catch (Exception e) {
			if (this.throwException) throw new ZXException(e);
			return createObject;
		}
	}

	/**
	 * Creates a ZXObject from a class.
	 * 
	 * @param clazz The class you want to create a instance of
	 * @return Returns an instance of the 
	 * @throws ZXException Thrown if createObject failes.
	 */
	public Object createObject(Class clazz) throws ZXException{
		Object createObject = null;
		if (trace.isFrameworkCoreTraceEnabled()) {
			trace.enterMethod();
			trace.traceParam("className", clazz.getName());
		}
		try {
		    
		    createObject= clazz.newInstance();
			return createObject;
			
		} catch (Exception e) {
			trace.addError("Failed to : Create Object ", e);
			if (log.isErrorEnabled()) {
				log.error("Parameter : className = " + clazz.getName());
			}
			if (this.throwException) throw new ZXException(e);
			return createObject;
		} finally {
			if (trace.isFrameworkCoreTraceEnabled()) {
				trace.returnValue(createObject);
				trace.exitMethod();
			}
		}
	}
    
    /**
	 * The director engine for the framework.
	 * 
	 * @param pstrDirector The name of the director
	 * @return Returns a resolved director.
	 * @throws ZXException Thrown if resolveDirector fails.
	 */
    public String resolveDirector(String pstrDirector) throws ZXException{
        if(trace.isFrameworkCoreTraceEnabled()) {
            trace.enterMethod();
            trace.traceParam("pstrDirector", pstrDirector);
        }
        
        String resolveDirector = null;
        
        try {
            
            resolveDirector = directorHandler.resolve(pstrDirector);
            return resolveDirector;
            
        } catch (Exception e) {
            trace.addError("Failed to : Resolve director.", e);
            if (log.isErrorEnabled()) {
                log.error("Parameter : pstrDirector = "+ pstrDirector);
            }
            if (throwException) throw new ZXException(e);
            return resolveDirector;
            
        } finally {
            if(trace.isFrameworkCoreTraceEnabled()) {
                trace.returnValue(resolveDirector);
                trace.exitMethod();
            }
        }
    }
    
    //---------------------------------------------------------
    //------------------------------------- ZX Parsing methods.
    //---------------------------------------------------------
    
    /**
     * Parse the zx config file.
     * 
     * When in production mode the parsing of zX config files is largely
     * static.
     * 
     * @param zXConfigFile The full filename including the path.
     * @throws Exception Throw if the parsing fails, we will leave the exception handling to the callee.
     */
    private void parseZXConfig(String zXConfigFile) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("Open file to parse : " + zXConfigFile);
        }
        
        /**
         * In production mode we want to cache as much
         * as we can. Basically all of the things that
         * does not change. eg : Application Name, Application Version etc..
         * 
         * However we still want to have flexibility for tracing level etc..
         */
        
        //-------------------------------------------------- zX Parsing
        
        File file = new File(zXConfigFile);
        if (!file.isFile()) {
            throw new ZXException("Failed to get file : No such file exists.", zXConfigFile);
        }
        
        Document doc = null;
        Element element;
        // In case we need to re-parse the settings for the application
        Settings objSettings = null;
        
        /**
         * Only get from the cache if the file is unmodified.
         */
        long lastModified = 0;
        if (cfgLastModified != 0) {
            lastModified = file.lastModified();
            if (lastModified == cfgLastModified) {
                doc = (Document)getCachedValue(Environment.CONFIG_DOM);
            }
        }
        
        /**
         * Do some checks to see if we should
         * re-parse the config settings.
         * 
         * 1) Is the static variable "settings" null? If it is we should parse
         * 2) If the former is false, we do a extra check to see if the DOM object for the settings has been cached.
         * If it has been cached we should leave the settings as that as because the config files have not been updated. This
         * is only applicable in production mode.
         */
        boolean blnParseConfig = settings == null      // We have never init the settings. 
                                 || doc == null;       // Has the dom object been cached ?
        
        if (blnParseConfig) {
            objSettings = new Settings();
            
            /**
             * Parse the xml config file
             */   
            if (log.isDebugEnabled()) {
                log.debug("Parse zx config file");
            }
            SAXBuilder sax = new SAXBuilder();
            sax.setValidation(false);
            doc = sax.build(file);
            
            /**
             * This is used by configValue method.
             */
            log.debug("Get XML top element");
            this.configXMLTop = doc.getRootElement().getChild("zX");

            String elementName;
            Iterator iter = this.configXMLTop.getChildren().iterator();
            while (iter.hasNext()) {
                element = (Element)iter.next();
                elementName = element.getName();
                
                if (elementName.equals("appName")) {
                    objSettings.setAppName(element.getText());
                // } else if (elementName.equals("baseDir")) { -- VB only
                } else if (elementName.equals("statusFileDir")) {
                	/** Make sure we always end with the final path seperator. */
                    objSettings.setStatusFileDir(element.getText() + File.separatorChar);
                } else if (elementName.equals("jbaseDir")) {
                    /** Make sure we always end with the final path seperator. */
                    objSettings.setBaseDir(element.getText() + File.separatorChar);
                } else if (elementName.equals("boDir")) {
                    objSettings.setBoDir(element.getText());
                } else if (elementName.equals("pageflowDir")) {
                    objSettings.setPageflowDir(element.getText());
                } else if (elementName.equals("queryDir")) {
                    objSettings.setQueryDir(element.getText());
                } else if (elementName.equals("templatesDir")) {
                    objSettings.setTemplatesDir(element.getText());
                } else if (elementName.equals("tmpDir")) {
                    objSettings.setTmpDir(element.getText());
                } else if (elementName.equals("sessionTimeOut")) {
                    objSettings.setSessionTimeOut(Integer.parseInt(element.getText()));
                } else if (elementName.equals("appMode")) {
                    objSettings.setAppMode(element.getText());  
                } else if (elementName.equals("appDate")) {
                    objSettings.setAppDate(element.getText());                  
                } else if (elementName.equals("appVersion")) {
                    objSettings.setAppVersion(element.getText());                   
                } else if (elementName.equals("sessionSource")) {
                    objSettings.setSessionSource(element.getText());
                } else if (elementName.equals("language")) {
                    objSettings.setLanguage(element.getText());
                } else if (elementName.equals("log")) {
                    parseLogSettings(objSettings, element);
                } else if (elementName.equals("trace")) {
                    parseTraceSettings(objSettings, element);
                    
                //------------------------------ Date formats
                } else if (elementName.equals("dateFormat")) {
                    objSettings.setStrDateFormat(element.getText());
                } else if (elementName.equals("timeFormat")) {
                    objSettings.setStrTimeFormat(element.getText());
                } else if (elementName.equals("timestampFormat")) {
                    objSettings.setStrTimestampFormat(element.getText());
                //------------------ New version compatibility checking.
                } else if (elementName.equals("requiredzXVersion")) {
                    parseRequiredzXVersion(objSettings, element);
                    
                } else if (elementName.equals("html")) {
                    objSettings.setWebSettings(new WebSettings(element));
                
                //------------------ Cache this elements for performance   
                } else if (elementName.equals("drctrFH")) {
                    objSettings.getTags().put("//drctrFH", element);
                } else if (elementName.equals("exprFH")) {
                    objSettings.getTags().put("//exprFH", element);
                } else if (elementName.equals("expressionTrace")) {
                    objSettings.getTags().put("//expressionTrace", element);
                } else if (elementName.equals("txHandlers")) {
                    objSettings.getTags().put("//txHandlers", element);
                }
                //------------------- Cache this elements for performance
            }
            /** Set the settings object to the new value */
            settings = objSettings;
        } else {
            //  This is used by configValue method.
            log.debug("Get XML top element");
            if (doc != null) {
                this.configXMLTop = doc.getRootElement().getChild("zX");
            }
        }

        //------------------------------------ Uncachable parsing
        /**
         * New datasource support which replaces the db stuff.
         * At the moment we cannot cache this as the datasources objects 
         * are statefull.
         */
        log.debug("Creating datasources.");
        element = this.configXMLTop.getChild("dataSources");
        setDataSources(new DataSources(element));
        //---------------------------------------------------- zX Parsing
        
        /**
         * See if there is a date overrule
         */
        log.debug("Get date overrule");
        if (StringUtil.len(getSettings().getAppDate()) != 0) {
            DateFormat dateFormat = getTimestampFormat();
            try {
                setAppDate(dateFormat.parse(settings.getAppDate()));
            } catch (ParseException e1) {
            	/**
            	 * Ignore exception
            	 */
            }
        }
        
        /**
         * Cache the parsed dom object when we are in production mode.
         */
        log.debug("Caching handle to dom object.");
        if (getSettings().getRunMode().pos == zXType.runMode.rmProduction.pos) {
            setCachedValue(Environment.CONFIG_DOM, doc);
            if (lastModified == 0) {
                lastModified = file.lastModified();
            }
            cfgLastModified = lastModified;
        }
        
        /**
         * We need to init the trace and logging stuff as soon as possible
         * as it is use even in parsing of zX configuration files like parseAuditAttriubutes.
         */
        
        /**
         * Start up the logger.
         */ 
        log.debug("About to initialise logger object.");
        log = LogFactory.getLog(this);
        
        /**
         * Initialize the tracing.
         */             
        log.debug("About to initialise trace object");
        trace = new Trace(this);
        
        /**
         * Parse the audit attributes. If we need to.
         * We should always have some audit attributes defined.
         */
        if (settings.getAuditAttributes() == null) {
            /**
             * Get definition of audit attributes 
             */
            AttributeCollection colAuditAttr = parseAuditAttributes();
            synchronized (ZX.class) {
                settings.setAuditAttributes(colAuditAttr);
            }
        }
    }
    
    /**
     * Parse the special XML file that contains the auditability columns .
     * @return Returns the attribute collection for the audit attributes.
     * 
     * @throws ZXException Throw if parseAuditattributes failes.
     */
    private AttributeCollection parseAuditAttributes() throws ZXException {
        AttributeCollection parseAuditAttributes = new AttributeCollection();
        
        if (trace.isFrameworkCoreTraceEnabled()) {
            trace.enterMethod();
        }
        
        try {
            // Init a descriptor.
            DescriptorParser objDesc = new DescriptorParserDomImpl();
            
            /**
             * Load the xml file :
             */
            Element objXMLTopNode = null;
            String strAuditFilename = fullPathName(settings.getBoDir()) + "zxAuditAttributes.xml";
            
            try {
                SAXBuilder sax = new SAXBuilder();
                sax.setValidation(false);
                
                Document doc = sax.build(new File(strAuditFilename));
                objXMLTopNode = doc.getRootElement();
            } catch (Exception e) {
                throw new NestableException("Could not parse xml file :" + strAuditFilename, e);
            }
            
            Element element;
            Attribute objAttribute;
            // Audit attributes

            Iterator objXMLNode = objXMLTopNode.getChildren().iterator();
            while (objXMLNode.hasNext()) {
                element = (Element) objXMLNode.next();
                
                objAttribute = objDesc.parseSingleAttribute(element);
                
                /**
                 * And add to collection
                 */
                parseAuditAttributes.put(objAttribute.getName(), objAttribute);
            }
            return parseAuditAttributes;
            
        } catch (Exception e) {
            trace.addError("Failed to add Audit Attributes", e);
            if (this.throwException) throw new ZXException(e);
            return parseAuditAttributes;
            
        } finally {
            if (trace.isFrameworkCoreTraceEnabled()) {
                trace.exitMethod();
            }
        }
    }
    
    //------------------------------------------ Parsing of Logging settings
    
    /**
     * Parses the logging settings for the framework. 
     * 
     * <pre>
     * 
     * This is used because the configValue is to slow and these variables are used quite often, 
     * unfortunately these values need to be stored in the ZX objects.
     * </pre>
     * 
     * @param objSettings A handle to the settings object.
     * @param objElement The element containing the logging settings
     * @throws Exception Thrown if the parsing fails.
     */
    private void parseLogSettings(Settings objSettings, Element objElement) throws Exception {
        String elementName;
        Element element;
        
        Iterator iter = objElement.getChildren().iterator();
        while(iter.hasNext()) {
            element = (Element)iter.next();
            elementName = element.getName();
            if (elementName.equals("fileName")) {
                objSettings.setLogFileName(element.getText());
            } else if (elementName.equals("active")) {
                objSettings.setLogActive(element.getText().equals("yes")?true:false);
            } else if (elementName.equals("append")) {
                objSettings.setLogAppend(element.getText().equals("yes")?true:false);
            } else if (elementName.equals("logLevel")) {
                objSettings.setLogLevel(element.getText());
            } else if (elementName.equals("logFactory")) {
                objSettings.setLogFactory(element.getText());
            } else if (elementName.equals("logFormat")) {
                objSettings.setLogFormat(element.getText());
            }            
        }
    }
    
    /**
     * Parses the tracing settings for the framework. 
     * 
     * <pre>
     * 
     * This is used because the configValue is to slow and these variables are used quite often, 
     * unfortunately thesevalues need to be stored in the ZX objects.
     * </pre>
     * 
     * @param objSettings A handle to the settings object. 
     * @param objElement The element containing the tracing settings
     * @throws Exception Thrown if the parsing fails.
     */    
    private void parseTraceSettings(Settings objSettings, Element objElement) throws Exception {        
        String elementName;
        Element element;
        Iterator iter = objElement.getChildren().iterator();
        while(iter.hasNext()) {
            element = (Element)iter.next();
            elementName = element.getName();
            if (elementName.equals("fileName")) {
                objSettings.setTraceFileName(element.getText());
            } else if (elementName.equals("active")) {
                objSettings.setTraceActive(element.getText().equals("yes")?true:false);
            } else if (elementName.equals("append")) {
                objSettings.setTraceAppend(element.getText().equals("yes")?true:false);
            } else if (elementName.equals("level")) {
                objSettings.setTraceLevel(new Integer(element.getText()).intValue());
            } else if (elementName.equals("logFormat")) {
                objSettings.setTraceFormat(element.getText());
            }            
        }
    }
    
    /**
     * Get the required zX version from the configuration file. This is a feature introduced
     * in V1.5 so we default to 1.4 if not set explicitly and assume that the application does
     * not support 1.5 features
     * 
     * @param objSettings The handle to the settings object. 
     * @param objElement The xml element containing the version details.
     * @throws Exception Thrown if parseRequiredzXVersion fails. Most probably a numberformat error.
     */
    private void parseRequiredzXVersion(Settings objSettings, Element objElement) throws Exception {
        String strTmp = objElement.getText();
        
        if (StringUtil.len(strTmp) > 0) {
            int intPos = strTmp.indexOf('.');
            if (intPos != -1) {
                objSettings.setRequiredzXVersionMajor(Integer.parseInt(strTmp.substring(0,intPos)));
                objSettings.setRequiredzXVersionMinor(Integer.parseInt(strTmp.substring(intPos + 1)));
            } else {
                objSettings.setRequiredzXVersionMajor(Integer.parseInt(strTmp));
                objSettings.setRequiredzXVersionMinor(1);
            }
        } else {
            objSettings.setRequiredzXVersionMajor(1);
            objSettings.setRequiredzXVersionMinor(4);
        } // Not set explicitly so assume 1.4
        
    }
    
    //---------------------------------------------------------
    //------------------------------------- ZX Parsing methods.
    //---------------------------------------------------------
    
    /**
     * True if the application support the zX version; false otherwise.
     * Based on requiredzXVersion from config file
     * 
     * @param pintMajor The major part of the version number.
     * @param pintMinor The minor part of the version number.
     * @return Whether the application is support by the current version of the framework.
     */
    public boolean zXVersionSupport(int pintMajor, int pintMinor) {
        boolean zXVersionSupport;
        if (pintMajor < settings.getRequiredzXVersionMajor()) {
            zXVersionSupport = true;
        } else if (pintMajor == settings.getRequiredzXVersionMajor()){
            if (pintMinor <= settings.getRequiredzXVersionMinor()) {
                zXVersionSupport = true;
            } else {
                zXVersionSupport = false;
            }
        } else {
            zXVersionSupport = false;
        }
        return zXVersionSupport;
    }
    
	/************************************************************************************
     * ---------------------------------------CACHING-----------------------------------*
	 ************************************************************************************/
    
    /**
     * @return Returns the cache provider
     */
    private static CacheProvider createCacheProvider() {
        /**
         * Default to EHCache
         */
        String cacheClassName = PropertiesUtil.getString(Environment.CACHE_PROVIDER, 
                                                         ZXCORE_PROPERTIES,
                                                         "org.hibernate.cache.EhCacheProvider");
        try {
            return (CacheProvider)ReflectUtil.classForName(cacheClassName).newInstance();
        } catch (Exception cnfe) {
            throw new NestableRuntimeException("Could not instantiate CacheProvider: " + cacheClassName, cnfe);
        }
        
    }
    
	/**
     * Get a value from the global cache.
     * 
	 * @param name The name of the cached value to get.
	 * @return Returns a cache value
	 */
	public Object getCachedValue(String name) {
	    Object getCachedValue = null;
        
        if (this.cache != null) {
            getCachedValue = this.cache.get(name);
            
        } else {
        	/**
        	 * No global cache specified use runtime cache
        	 */
        	getCachedValue = getSettings().getTags().get(name);
        }
        
	    return getCachedValue;
	}
	
	/**
     * Sets a value in the global cache.
     * 
	 * @param name The name of object.
	 * @param object Object to cache.
	 */
	public synchronized void setCachedValue(String name, Object object) {
		
        if (this.cache != null) {
            this.cache.put(name, object);
        } else {
        	/**
        	 * No global cache specified
        	 */
        	getSettings().getTags().put(name, object);
        }
        
	}
    
    /**
     * @return Returned whether ZX is stale and was retrieved from the cached.
     */
    public boolean isInCached() {
        return this.isInCached;
    }
    
    /**
     * Always call this at the very end of each jsp or exit point of your program.
     */
    public void cleanup () {
        /**
         * And store the session if not logged-off
         * Store the session data.
         */
        if (this.session != null) {
            this.session.store();
        }
        
        /**
         * Disconnect the datasources.
         */
        this.dataSources.disConnect();
        
        /**
         * It we now call getZX() we will get a freesh handle to zX. This is 
         * used when we retrieve a cached handle to zX.
         */
        this.isInCached = true;
        
    }
    
	/************************************************************************************
	 * ---------------------------------------CACHING-----------------------------------*
	 ************************************************************************************/
    
    //-----------------------------  Delegate some of the settings properties
    //
    // These are mostly static values, however we may need more flexibility for
    // tracing. And the language setting it determined by users language.
    //
    
    /**
     * @return Returns the application current RunMode.
     */
    public zXType.runMode getRunMode() {
        return getSettings().getRunMode();
    }
    
    /**
     * @return Returns path of bo directory (Normally a relative path).
     */
    public String getBoDir() {
        return getSettings().getBoDir();
    }
    
    /**
     * @return Returns the path of the pageflow directory (Normally a relative path).
     */
    public String getPageflowDir() {
        return getSettings().getPageflowDir();
    }
    
    /**
     * @return Returns the query defintion path.
     */
    public String getQueryDir() {
        return getSettings().getQueryDir();
    }
    
    /**
     * @return Returns the datasource for Session data.
     */
    public zXType.sessionSouce getSessionSource() {
        return getSettings().getSessionSource();
    }
    
    /**
     * @return Returns the application name.
     */
    public String getAppName() {
        return getSettings().getAppName();
    }
    
    /**
     * @return Returns the session timeout in minutes.
     */
    public int getSessionTimeOut() {
        return getSettings().getSessionTimeOut();
    }
    
    //------------------ Cached date formatting.
    
    /**
     * @return Returns the dateFormatter for Times.
     */
    public DateFormat getTimeFormat() {
        return getSettings().getTimeFormat();
    }
    
    /**
     * @return Returns the dateformatter for Timestamps.
     */
    public DateFormat getTimestampFormat() {
        return getSettings().getTimestampFormat();
    }
    
    /**
     * @return Returns the dateFormatter for Dates.
     */
    public DateFormat getDateFormat() {
        return getSettings().getDateFormat();
    }
    
    //-------------------- Tracing/Logging settings.
    
    /**
     * @return Returns whether tracing is active.
     */
    public boolean isTraceActive() {
        return settings.isTraceActive();
    }
    
    /**
     * @return Returns the current tracelevel of the application.
     */
    public int getTraceLevel() {
        return settings.getTraceLevel();
    }
    
    private String language;
    /**
     * @return Returns the application default language.
     */
    public String getLanguage() {
        /**
         * See if there is a runtime value for the language.
         */
        if (this.language != null) {
            return language;
        }
        
        return getSettings().getLanguage();
    }
    /**
     * The runtime language for the application.
     * 
     * @param language The current language for the Application.
     */
    public void setLanguage(String language) {
        this.language = language;
    }
    
    /**
     * @return Returns the auditAttributes.
     */
    public AttributeCollection getAuditAttributes() {
        return getSettings().getAuditAttributes();
    }
    
    /**
     * @return Returns the environment settings for the application.
     */
    public Settings getSettings() {
        return settings;
    }
    
    //------------------------ Create instant value property. This may not be needed or used.
    
    /**
     * Return instant value property with boolean value set
     *  
     * @param pblnValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with boolean value set
     */
    public static BooleanProperty blnValue(Boolean pblnValue, boolean pblnIsNull) {
        return new BooleanProperty(pblnValue, pblnIsNull);
    }

    /**
     * Return instant value property with double value set
     *  
     * @param pdblValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with boolean value set
     */
    public static BooleanProperty blnValue(boolean pdblValue, boolean pblnIsNull) {
        return new BooleanProperty(pdblValue, pblnIsNull);
    }

    /**
     * Return instant value property with date value set
     *  
     * @param pdatValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with boolean value set
     */
    public static DateProperty datValue(Date pdatValue, boolean pblnIsNull) {
        return new DateProperty(pdatValue, pblnIsNull);
    }
    
    /**
     * Return instant value property with double value set
     *  
     * @param pdblValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with double value set
     */
    public static DoubleProperty dblValue(Double pdblValue, boolean pblnIsNull) {
        return new DoubleProperty(pdblValue, pblnIsNull);
    }
    
    /**
     * Return instant value property with double value set
     *  
     * @param pdblValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with double value set
     */
    public static DoubleProperty dblValue(double pdblValue, boolean pblnIsNull) {
        return new DoubleProperty(pdblValue, pblnIsNull);
    }

    /**
     * Return instant value property with long value set
     *  
     * @param plngValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with long value set
     */
    public static LongProperty lngValue(Long plngValue, boolean pblnIsNull) {
        return new LongProperty(plngValue, pblnIsNull);
    }
    
    /**
     * Return instant value property with long value set
     *  
     * @param plngValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with long value set
     */
    public static LongProperty lngValue(long plngValue, boolean pblnIsNull) {
        return new LongProperty(plngValue, pblnIsNull);
    }
    
    /**
     * Return instant value property with string value set
     *  
     * @param pstrValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with string value set
     */
    public static StringProperty strValue(String pstrValue, boolean pblnIsNull) {
        return new StringProperty(pstrValue, pblnIsNull);
    }
    
    /**
     * Return instant value property with string value set
     *  
     * @param pstrValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with string value set
     */
    public static StringProperty strValue(char pstrValue, boolean pblnIsNull){
        return new StringProperty(pstrValue + "", pblnIsNull);
    }
    
    /**
     * Return instant value property with string value set
     *  
     * @param pstrValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with string value set
     */
    public static StringProperty strValue(char[] pstrValue, boolean pblnIsNull){
        return new StringProperty(new String(pstrValue), pblnIsNull);
    }
    
    /**
     * Return instant value property with string value set
     *  
     * @param pstrValue Value for property
     * @param pblnIsNull Set null flag
     * @return Return instant value property with string value set
     */
    public static StringProperty strValue(StringBuffer pstrValue, boolean pblnIsNull) {
        return new StringProperty(pstrValue.toString(), pblnIsNull);
    }
    
    /**
     * Return instant value property with string value set
     *  
     * @return Return instant value property with string value set
     */
    public static StringProperty nullValue() {
        StringProperty nullValue = new StringProperty("", true);
        nullValue.setValuesToDefault();
        nullValue.setNull(true);
        return nullValue;
    }
    
    //------------------------ Object overriden methods.
    
    /**
     * @see java.lang.Object#finalize()
     */
    public void finalize() {
        try {
            if (!isInCached) {
                log.error("Serious Error : We can calling finalize without calling cleanup.");
                cleanup();
            }
        } catch (Exception e) {
            log.error("Failed to perform cleanup", e);
        }
    }
}